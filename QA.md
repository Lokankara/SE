1. JVM-JDK-JRE. Что это такое? Кто кого включает и как взаимодействуют.
2. Как скомпилировать и запустить класс, используя консоль?
3. ЛТ-компилятор
4. Что такое classpath. Если в classpath есть две одинаковые библиотеки (или разные
   версии одной библиотеки), объект класса из какой библиотеки создастся?
5. Какие области памяти использует java для размещения простых типов, объектов,
   ссылок, констант, методов, пул строк и т.д. Базовая внутренняя структура памяти JVM.
6. Пакеты в java. Зачем применяются? Принцип именования пакетов.
7. Модификаторы доступа.
8. Почему метод mainO объявлен как public static void?
9. Что такое package level access. Пример использования.
10. Может ли объект получить доступ к private-переменной класса? Если, да, то какими
    способами?
11. Классы-оболочки. Integer cache (пул чисел).
12. Autoboxing и unboxing. Принцип действия на примерах.
13. Задача. int a = 1;
    Integer b = 2;
    int c = atb; - результат?
    А каков будет результат если Integer b = null ?
14. Что такое var? Достоинства и недостатки.
15. LocalDateTime, ZonedDateTime and OffsetDateTime difference. Что такое Instant?

16. В чем разница между созданием строки как new String() и литералом (при помощи
    двойных кавычек)?
17. Как реализуется класс String, какие поля там есть?
18. Как работает метод substring() класса String?
19. Понятие Юникод. UTF-8, описание кодировки. Отличие от UTF-16.
20. String, StringBuilder, StringBuffer. Отличия. Почему эти классы объявлены как final?
    Java Classes
21. Базовый класс в java. Методы класса.
22. OOP abstraction. Принципы ООП.
23. Правила переопределения метода boolean eguals(Object o).
24. Зачем переопределять методы hashCode и equals одновременно?
25. Задача. Написать метод equals для класса, содержащего одно поле типа String или
    StringBuilder.
26. Правила Дереопределения метода int hashCodeO. Можно ли в качестве результата
    возвращать константу?
27. Правила переопределения метода clone(.
28. Чем отличаются finally и finalize? Для чего используется ключевое слово final?
29. JavaBeans: основные требования к классам Веап-компонентов, соглашения об именах.
30. Как работает Garbage Collector. Какие самые распространенные алгоритмы? Можно
    ли самому указать сборщику мусора, какой объект удалить из памяти.
31. В каких областях памяти хранятся значения и объекты, массивы?
32. Какие идентификаторы по умолчанию имеют поля интерфейса?
33. Ассоциации. Композиция и агрегация.
34. Чем отличается абстрактный класс от интерфейса?
35. Когда применять интерфейс логичнее, а когда абстрактный класс?
36. Бывают ли интерфейсы без методов? Для чего?
37. Перегрузка и переопределение. Можно ли менять модификатор доступа метода, если
    да, то каким образом?
38. Перегрузка и переопределение. Можно ли менять возвращаемый тип метода, если да,
    то как? Можно ли менять тип передаваемых параметров?
39. Каким образом передаются переменные в методы, по значению или по ссылке?
40. Что такое конструктор по умолчанию?
41. Свойства конструктора. Способы его вызова.
42. Mutable и Immutable кладсы. Привести примеры из java core. Как создать класс,
    который будет immutable. Класс record.
43. static - что такое? Что будет, если значение атрибута изменить через объект класса?
    Всегда ли static поле содержит одинаковые значения для всех его объектов?
44. Может ли статический метод быть перегружен нестатическим? Переопределен?
45. Внутренние классы. Какие бывают и для каких целей используются? Области
    видимости данных при определенных ситуациях.
46. Анонимные классы. Практическое применение. Для каких классов нельзя создать
    анонимный класс?
47. Generics. Что это такое и для чего применяются. Во что превращается во время
    компиляции и выполнения? Использование wildcards.
48. Что такое епит? Область применения. Какое использование перечисления
    некорректно? Привести примеры.
49. Отличия в применении интерфейсов Comparator и Comparable?
50. Класс Optional. Как помогает бороться с null? Пример хорошего и некорректного
    использования.
51. Принципы SOLID, Yagni, Kiss, Dry.
52. Если Interf - это интерфейс, а Clazz - это класс, который реализует интерфейс и в нем
    объявлен метод (которого нет в Intert), например, methodO. Корректно ли выражение:
    Interf a = new ClazzO;
    a. methodO;
    То же самое, если Interf I не интерфейс, а абстрактный класс.
53. Что такое ClassLoader? Если изменить static переменную в классе, загруженном
    одним ClassLoader, что будет видно в том же классе, загруженном другим. Возможно
    ли синглтоны создавать несколько раз?
54. Какие бывают потоки ввода вывода?
55. Что такое сериализация, для чего нужна, когда применяется? Ключевое слово
    transient, для чего нужно? Сериализация static-полей.
56. Возможно ли сохранить(сериализация) объект не в байт-код, а в xml-файл?
    Java Exceptions
57. Опишите нерархию исключений.
58. Что такое checked и unchecked Exception? Их отличия.
59. Опишите работу блока try-catch-finally. Может ли работать данный блок без catch?
    Порядок блоков catch. Multicatch.
60. Блок try with resources.
70. Что такое процесс? Что такое поток? Состояния потока.
71. Как создать поток? Какими способами можно запустить поток?
72. Как корректно завершить работу потока? (Иногда говорят, убить поток).
73. Как выполнить набор команд в отдельном потоке?
74. Как работают методы waitO и notify0/notifyAllO?
75. Чем огличается работа метода wait с параметром и без параметра?
76. Как работает метод yieldO? Чем отличаются методы Thread.sleep) и Thread.yield)?
77. Чем отличаются методы sleep и wait(long millis)?
78. Как работает метод joinO?
79. Что такое синхронизациу? Зачем она нужна? Для чего нужно ключевое слово
    synchronized? Какие способы синхронизации вы знаете? Какими средствами
    достигается?
80. По каким объектам синхронизируются статические и нестатические методы?
81. Отличия работы synchronized от Lock?
82. Есть ли у Lock механизм. аналогичный механизму wait notify y sunchronized?
83. Что такое deadlock? Нарисовать схему, как это происхолит.
90. Сравнить ArrayList и LinkedList.
91. Сравнить HashMap и Hashtable.
92. Сравнить HashSet и TreeSet.
93. Принцип работы и реализации HashMap. Изменения HashMap в Java8.
94. Чем отличается ArrayList от Vector?
95. Особенности интерфейса Set.
96. Как добавляются объекты в HashSet?
97. Какими способами можно отсортировать коллекцию? (привести три способа)
98. Коллекции из пакета concurrent. Их особенности.
99. Что происходит при добавлении в ArrayList нового элемента и как это реализовано.
100. Thread-safe and non-thread safe collections.
101. Метод для преобразования потоко-небезопасной коллекции в потоко-
     безопасную.
102. Какие потокобезопасные коллекции более «быстрые» - legacy (Vector,
     HashTable) или из пакета concurrent?
103. Если в коллекций часто добавлять элементы, и удалять, какую лучше
     использовать? Почему? Как они устроены?
104. Как правильно удалить элемент из коллекции при итерации в цикле?
105. Как правильно удалить элемент из Array List (или другой коллекции) при
     поиске этого элемента в цикле?
106. fail-fast/fail-safe iterators
107. Задача. Написать метод, в котором проверяется HashMap на наличие в нем
     некоторого значения, и его извлечения, если такого значения нет, надо добавить
     значение с пустой строкой и её вернуть. Написать код, чтобы он был как можно более
     эффективным (меньше затратных действий).
108. Задача. Как быстро получить копию коллекции? Записать код преобразования.
109. Задача. Дан массив отсортированных чисел. Необходимо найти все пары,
     которые в сумме дают заданное число.
110. Функциональные интерфейсы. Определение. Default & static методы. Область
     применения.
111. Лямбда-выражение. Замыкания. Синтаксис. Характеристики.
112. Function, Supplier, Predicate, Consumer. Их применение.
113. Ссылка на метод? Что это такое? Или это все же ссылка на объект?
114. Собственные функциональные интерфейсы.
115. Чем Stream отличается от коллекции?
116. Промежуточные и терминальные операции.
117. Методы: map vs flatMapO
118. Что такое потоковая обработка данных.
119. Нововведения начиная с Java 8.
120. Как создать Connection? Последовательность действий необходимых для
     выполнения запроса к БД.
121. Как правильно закрыть Connection?
122. Какие есть типы драйверов для соединения с СУБД?
123. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после
     первого вызова PreparedStatement? Будет ли тот же самый эффект как и от
     PreparedStatement, если формировать запрос просто в строке и отправлять его в
     Statement?
124. Зачем нужен CallableStatement?
125. Огличие executeUpdateO or executeQueryO.
126. Как в объекте ResultSet вернуться в предыдущую строку? Всегда ли можно
     вернуться в предыдущую строку?
127. Как получить сгенерированный СУБД первичный ключ без выполнения
     дополнительного запроса к БД?
128. Транзакции. Принципы ACID.
129. Уровни изоляции ранзакций. Виды чтения. Точки сохранения.
130. SQL injection. Как работает и как защищаться?

## Design Patterns
1. Зачем нужны паттерны? Привести примеры из проекта.
2. Какие паттерны вы знаете и как их применяет Java SE.
3. Factory Method, Builder
4. Singleton (class Runtime)
5. Как сделать чтобы в Singleton не работала двойная блокировка?
6. Как у Singleton создать второй объект? И как воспрепятствовать этому.
7. Prototype
8. Command
9. Composite
10. Chain of responsibility (Filter, closing io stream, closing connection)
11. State (Thread.State)
12. Iterator (Enumeration, Iterator, Listiterator, навигация по ResultSet)
13. Proxy
14. Observer (Listener-s)
15. Wrapper
16. Immutable
17. MVC
18. DAO vs. Repository
1. Что вХодит в JEE?
2. Какие бывают WebServife?
3. RESTful сервис. Принципы работы.